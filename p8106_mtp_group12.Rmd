---
title: "p8106_mtp"
author: "Abhishek Ajay and PengXuan Chen"
date: "April 2, 2019"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(glmnet)
library(caret)
library(corrplot)
library(splines)
library(ggplot2)
library(mgcv)
library(earth)

set.seed(2)
```

##Introduction

**Describe your data set. Provide proper motivation for your work.**

What questions are you trying to answer?


The following dataset has been obtained from the UCI Machine Learning Rpository. We are using the dataset that contains daily counts of bike rentals by both registered and casual members from the Capital Bikeshare System during the years 2011 and 2012. This dataset also contains weather data for each that's been extracted from the www.freemeteo.com while it uses the dc.gov page to extract information about the binary holiday column. 

Capital Bikeshare has over 350 stations in Washington, D.C., Alington, VA and MD, etc. 

We are trying to use this dataset to see if temperature, weather and type of day (working day, weekend or a holiday) have any effect on the amount of bike rentals on any given day. Simply put, we're trying to forecast bike rentals on any day. This can have a ton of implications in traffic management. Forecasting the amount of bikes on the road can give a better sense of travel time and allowing taxi services to provide more accurate "estimated time of arrival" estimates. 

**How did you prepare and clean the data?**


```{r}
day = read.csv("./data/day.csv") %>% 
  janitor::clean_names() %>% 
  select(-c(dteday, instant)) %>% 
  mutate(season = as.factor(season), 
         yr = as.factor(yr), 
         mnth = as.factor(mnth), 
         holiday = as.factor(holiday), 
         weekday = as.factor(weekday), 
         workingday = as.factor(workingday)
         #dteday = as.vector(dteday)
         ) 
  
x = day  
x = model.matrix(casual + registered + cnt~., x)[,-1]
y = day$cnt
corrplot(cor(x))
```


```{r}
#Non Linear Methods from L5.pdf
theme1 <-trellis.par.get()
theme1$plot.symbol$col <-rgb(.2, .4, .2, .5)
theme1$plot.symbol$pch <- 16
theme1$plot.line$col <-rgb(.8, .1, .1, 1)
theme1$plot.line$lwd <- 2
theme1$strip.background$col <-rgb(.0, .2, .6, .2)
trellis.par.set(theme1)
featurePlot(x, y, plot = "scatter", labels =c("","Y"),type =c("p"), layout =c(4, 2))
```

The above plots clearly show that there's non linear relationship between "cnt" and temp, atemp, hum and windspeed. What follows is us trying to fit univariate non-linear models and GAM to investigate the association between cnt and the four predictors.


smooth splines 
```{r}
#temp
fit.ss <-smooth.spline(day$temp, day$cnt)
fit.ss$df

templims <-range(day$temp)
temp.grid <-seq(from = templims[1],to = templims[2], by = 0.0001)
length(temp.grid)

pred.ss <-predict(fit.ss,
                  x = temp.grid)


pred.ss.df <-data.frame(pred = pred.ss$y,
                        temp = temp.grid)

p <-ggplot(data = day,aes(x = temp, y = cnt))+
  geom_point(color =rgb(.2, .4, .2, .5))

p+geom_line(aes(x = temp, y = pred), data = pred.ss.df,color =rgb(.8, .1, .1, 1))+ theme_bw()

#humidity
fit.ss <-smooth.spline(day$hum, day$cnt)
fit.ss$df

humlims <-range(day$hum)
hum.grid <-seq(from = humlims[1],to = humlims[2], by = 0.001)
length(hum.grid)

pred.ss <-predict(fit.ss,
                  x = hum.grid)


pred.ss.df <-data.frame(pred = pred.ss$y,
                        hum = hum.grid)

p <-ggplot(data = day,aes(x = hum, y = cnt))+
  geom_point(color =rgb(.2, .4, .2, .5))

p+geom_line(aes(x = hum, y = pred), data = pred.ss.df,color =rgb(.8, .1, .1, 1))+ theme_bw()

#pretty persuasive, since 0.5-0.75 is the best comfortable humidity

#windspeed
fit.ss <-smooth.spline(day$windspeed, day$cnt)
fit.ss$df

windspeedlims <-range(day$windspeed)
windspeed.grid <-seq(from = windspeedlims[1],to = windspeedlims[2], by = 0.001)
length(windspeed.grid)

pred.ss <-predict(fit.ss,
                  x = windspeed.grid)


pred.ss.df <-data.frame(pred = pred.ss$y,
                        windspeed = windspeed.grid)

p <-ggplot(data = day,aes(x = windspeed, y = cnt))+
  geom_point(color =rgb(.2, .4, .2, .5))

p+geom_line(aes(x = windspeed, y = pred), data = pred.ss.df,color =rgb(.8, .1, .1, 1))+ theme_bw()


# windspeed ^  --  cnt V

#atemp
fit.ss <-smooth.spline(day$atemp, day$cnt)
fit.ss$df

atemplims <-range(day$atemp)
atemp.grid <-seq(from = atemplims[1],to = atemplims[2], by = 0.01)
length(atemp.grid)

pred.ss <-predict(fit.ss,
                  x = atemp.grid)


pred.ss.df <-data.frame(pred = pred.ss$y,
                        atemp = atemp.grid)

p <-ggplot(data = day,aes(x = atemp, y = cnt))+
  geom_point(color =rgb(.2, .4, .2, .5))

p+geom_line(aes(x = atemp, y = pred), data = pred.ss.df, color =rgb(.8, .1, .1, 1))+ theme_bw()
```

##GAM
```{r}
gam.m1 = gam(cnt~ season + yr + mnth + holiday + weekday + workingday + weathersit + temp + atemp + hum + windspeed, data = day)

gam.m2 = gam(cnt~ season + yr + mnth + holiday + weekday + workingday + weathersit + s(temp) + atemp + hum + windspeed, data = day) # s:temp
gam.m3 = gam(cnt~ season + yr + mnth + holiday + weekday + workingday + weathersit + temp + s(atemp) + hum + windspeed, data = day) # s:atemp
gam.m4 = gam(cnt~ season + yr + mnth + holiday + weekday + workingday + weathersit + temp + atemp + s(hum) + windspeed, data = day) # s:hum
gam.m5 = gam(cnt~ season + yr + mnth + holiday + weekday + workingday + weathersit + temp + atemp + hum + s(windspeed), data = day) # s:windspeed

anova(gam.m1, gam.m2, test = "F")
anova(gam.m1, gam.m3, test = "F")  
anova(gam.m1, gam.m2, gam.m3, gam.m4, gam.m5, test = "F")

par(mfrow=c(2,2))
plot(gam.m2)
plot(gam.m3)
plot(gam.m4)
plot(gam.m5)

#deleting the yr and mnth variables

gam.m1a = gam(cnt~ season +  holiday + weekday + workingday + weathersit + temp + atemp + hum + windspeed, data = day)


gam.m2a = gam(cnt~ season +  holiday + weekday + workingday + weathersit + s(temp) + atemp + hum + windspeed, data = day) # s:temp
gam.m3a = gam(cnt~ season +  holiday + weekday + workingday + weathersit + temp + s(atemp) + hum + windspeed, data = day) # s:atemp
gam.m4a = gam(cnt~ season +  holiday + weekday + workingday + weathersit + temp + atemp + s(hum) + windspeed, data = day) # s:hum
gam.m5a = gam(cnt~ season +  holiday + weekday + workingday + weathersit + temp + atemp + hum + s(windspeed), data = day) # s:windspeed

anova(gam.m1, gam.m2, test = "F")
anova(gam.m1, gam.m3, test = "F")

par(mfrow=c(2,2))
plot(gam.m2a)
plot(gam.m3a)
plot(gam.m4a)
plot(gam.m5a)

```

```{r}
#GCV to select df

ctrl1 <-trainControl(method = "cv", number = 10)
set.seed(2)
gam.fit <-train(x, y,method = "gam",tuneGrid =data.frame(method = "GCV.Cp", select =c(TRUE,FALSE)),trControl = ctrl1)

gam.fit$bestTune
gam.fit$finalModel

x_2 = 
  day %>% 
  select(-c( casual, registered, cnt, yr, mnth))

x_2 = model.matrix(~., x_2)



set.seed(3)
gam.fit2 <-train(x_2, y,method = "gam",tuneGrid =data.frame(method = "GCV.Cp", select =c(TRUE,FALSE)),trControl = ctrl1)

gam.fit2$bestTune
gam.fit2$finalModel
```

?The deviance is pretty huge of those ANOVA?

GCV score is too large. 

```{r}
#poisson regression for categorical terms, exclude yr and mnth
day.glm1 <- glm(cnt~season + holiday + weekday + workingday + weathersit + temp + atemp + hum + windspeed, family=poisson, data=day)
summary(day.glm1)

```

poisson regression is a nonlinear regression for discrete outcomes(when response is a count).  

```{r}
#mars
mars_grid <-expand.grid(degree = 1:2,nprune = 2:10)
set.seed(2)
mars.fit <-train(x, y,method = "earth",tuneGrid = mars_grid,trControl = ctrl1)
ggplot(mars.fit)
mars.fit$bestTune


coef(mars.fit$finalModel)
bwplot(resamples(list(mars = mars.fit,gam = gam.fit)), metric = "RMSE")
```



#Linear Model (less flexibility but more interpretability)


```{r}
x_1 = 
  day %>% 
  select(-c( casual, registered, cnt))

x_1 = model.matrix(~., x_1)

ridge.mod <-glmnet(x_1, y, alpha=0, lambda =exp(seq(-1, 10, length=100)))
ridge.mod$lambda

dim(coef(ridge.mod))
```

we dropped the dteday because it does is a factor variable with too many levels and it basically is the same as the index which does not tells us anything in this test. 

x_1: all independent variables
y: cnt---the response

```{r}
set.seed(2)
cv.ridge <-cv.glmnet(x_1, y,alpha = 0,lambda =exp(seq(-1, 10, length=100)),type.measure = "mse")
plot(cv.ridge)

plot_glmnet(ridge.mod, xvar = "rlambda")

best.lambda = cv.ridge$lambda.min
best.lambda
predict(ridge.mod, s = best.lambda, type="coefficients")
```


```{r}
cv.lasso <-cv.glmnet(x_1, y,alpha = 1,lambda =exp(seq(-1, 10, length=100)),type.measure = "mse")
cv.lasso$lambda.min
plot(cv.lasso)

plot_glmnet(cv.lasso$glmnet.fit)

predict(cv.lasso, s="lambda.min", type="coefficients")
```

? why is that lasso best lambda is 1 ?

